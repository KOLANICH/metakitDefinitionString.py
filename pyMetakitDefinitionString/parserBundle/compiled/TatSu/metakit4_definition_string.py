#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import annotations

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname  # noqa
from tatsu.infos import ParserConfig
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class metakit4_definition_stringBuffer(Buffer):
	def __init__(self, text, /, config: ParserConfig = None, **settings):
		config = ParserConfig.new(
			config,
			owner=self,
			whitespace=None,
			nameguard=None,
			comments_re=None,
			eol_comments_re=None,
			ignorecase=False,
			namechars="",
			parseinfo=False,
		)
		config = config.replace(**settings)
		super().__init__(text, config=config)


class metakit4_definition_stringParser(Parser):
	def __init__(self, /, config: ParserConfig = None, **settings):
		config = ParserConfig.new(
			config,
			owner=self,
			whitespace=None,
			nameguard=None,
			comments_re=None,
			eol_comments_re=None,
			ignorecase=False,
			namechars="",
			parseinfo=False,
			keywords=KEYWORDS,
		)
		config = config.replace(**settings)
		super().__init__(config=config)

	@tatsumasu()
	def _subFields_(self):  # noqa
		self._scalarOrView_()
		self.name_last_node("first_subField")
		self._rest_subFields_with_delF_()
		self.name_last_node("rest_subFields_with_del")
		self._define(["first_subField", "rest_subFields_with_del"], [])

	@tatsumasu()
	def _scalarOrView_(self):  # noqa
		with self._choice():
			with self._option():
				self._scalar_()
				self.name_last_node("scalarF")
				self._define(["scalarF"], [])
			with self._option():
				self._view_()
				self.name_last_node("viewF")
				self._define(["viewF"], [])
			self._error("expecting one of: " "<scalar> <view> <word>")
		self._define(["scalarF", "viewF"], [])

	@tatsumasu()
	def _view_(self):  # noqa
		self._word_()
		self.name_last_node("name")
		self._SubFieldsStart_()
		self._body_()
		self.name_last_node("bodyF")
		self._SubFieldsEnd_()
		self._define(["bodyF", "name"], [])

	@tatsumasu()
	def _scalar_(self):  # noqa
		self._word_()
		self.name_last_node("name")
		self._Colon_()
		self._TypeSpecifier_()
		self.name_last_node("typeF")
		self._define(["name", "typeF"], [])

	@tatsumasu()
	def _body_(self):  # noqa
		with self._choice():
			with self._option():
				self._subFields_()
				self.name_last_node("subFieldsF")
				self._define(["subFieldsF"], [])
			with self._option():
				self._IndirectMarker_()
				self.name_last_node("selfF")
				self._define(["selfF"], [])
			self._error("expecting one of: " "'^' <IndirectMarker> <scalar>" "<scalarOrView> <subFields> <view>")
		self._define(["selfF", "subFieldsF"], [])

	@tatsumasu()
	def _rest_subFields_with_delF_(self):  # noqa
		def block0():
			self._rest_subField_with_delF_()

		self._closure(block0)

	@tatsumasu()
	def _rest_subField_with_delF_(self):  # noqa
		self._OptionsSeparator_()
		self._scalarOrView_()
		self.name_last_node("rest_subField")
		self._define(["rest_subField"], [])

	@tatsumasu()
	def _word_(self):  # noqa
		def block0():
			self._wordPiece_()

		self._positive_closure(block0)

	@tatsumasu()
	def _wordPiece_(self):  # noqa
		with self._choice():
			with self._option():
				self._TypeSpecifier_()
			with self._option():

				def block1():
					self._OtherWordChars_()

				self._positive_closure(block1)
			self._error("expecting one of: " "<OtherWordChars> <TypeSpecifier>" "[0-9ACEGHJ-LN-RT-Z_aceghj-ln-rt-z]" "[BDFIMSbdfims]")

	@tatsumasu()
	def _SubFieldsStart_(self):  # noqa
		self._token("[")

	@tatsumasu()
	def _SubFieldsEnd_(self):  # noqa
		self._token("]")

	@tatsumasu()
	def _Colon_(self):  # noqa
		self._token(":")

	@tatsumasu()
	def _OptionsSeparator_(self):  # noqa
		self._token(",")

	@tatsumasu()
	def _IndirectMarker_(self):  # noqa
		self._token("^")

	@tatsumasu()
	def _OtherWordChars_(self):  # noqa
		self._pattern("[0-9ACEGHJ-LN-RT-Z_aceghj-ln-rt-z]")

	@tatsumasu()
	def _OtherWordCharsOther_(self):  # noqa
		self._pattern("[0-9_]")

	@tatsumasu()
	def _OtherWordCharsUpper_(self):  # noqa
		self._pattern("[ACEGHJ-LN-RT-Z]")

	@tatsumasu()
	def _OtherWordCharsLower_(self):  # noqa
		self._pattern("[aceghj-ln-rt-z]")

	@tatsumasu()
	def _TypeSpecifier_(self):  # noqa
		self._pattern("[BDFIMSbdfims]")

	@tatsumasu()
	def _TypeSpecifierUpper_(self):  # noqa
		self._pattern("[BDFIMS]")

	@tatsumasu()
	def _TypeSpecifierLower_(self):  # noqa
		self._pattern("[bdfims]")


class metakit4_definition_stringSemantics:
	def subFields(self, ast):  # noqa
		return ast

	def scalarOrView(self, ast):  # noqa
		return ast

	def view(self, ast):  # noqa
		return ast

	def scalar(self, ast):  # noqa
		return ast

	def body(self, ast):  # noqa
		return ast

	def rest_subFields_with_delF(self, ast):  # noqa
		return ast

	def rest_subField_with_delF(self, ast):  # noqa
		return ast

	def word(self, ast):  # noqa
		return ast

	def wordPiece(self, ast):  # noqa
		return ast

	def SubFieldsStart(self, ast):  # noqa
		return ast

	def SubFieldsEnd(self, ast):  # noqa
		return ast

	def Colon(self, ast):  # noqa
		return ast

	def OptionsSeparator(self, ast):  # noqa
		return ast

	def IndirectMarker(self, ast):  # noqa
		return ast

	def OtherWordChars(self, ast):  # noqa
		return ast

	def OtherWordCharsOther(self, ast):  # noqa
		return ast

	def OtherWordCharsUpper(self, ast):  # noqa
		return ast

	def OtherWordCharsLower(self, ast):  # noqa
		return ast

	def TypeSpecifier(self, ast):  # noqa
		return ast

	def TypeSpecifierUpper(self, ast):  # noqa
		return ast

	def TypeSpecifierLower(self, ast):  # noqa
		return ast


def main(filename, start=None, **kwargs):
	if start is None:
		start = "subFields"
	if not filename or filename == "-":
		text = sys.stdin.read()
	else:
		with open(filename) as f:
			text = f.read()
	parser = metakit4_definition_stringParser()
	return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == "__main__":
	import json
	from tatsu.util import asjson

	ast = generic_main(main, metakit4_definition_stringParser, name="metakit4_definition_string")
	data = asjson(ast)
	print(json.dumps(data, indent=2))
